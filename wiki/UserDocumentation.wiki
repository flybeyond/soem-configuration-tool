#summary One-sentence summary of this page.
Here is the content of the modules
= Introduction =

While SOEM library provides network configuration only through slaves' scan, with this tool you can configure your network by parsing the ENI XML file generated by TwinCAT.
Moreover this tool provides an implementation of the State Machine, so you can execute whatever transition, thanks to the init commands list included in the ENI XML file.



=Data structures=

This tool acts like an application layer for the SOEM, so no modification to the current version of SOEM is needed. 
Since Soem doesn't provide space for some information contains in the ENI XML file, new structures has been crerated. For example:
-structure ec_slaveMore, wich works in parallel with pre-existent ec_slave of SOEM;
-Init_commands. Since the number of  init command is variable (both for slave and transition), this command are inserted in dynamic lists. Obviously, it has been created also the functions to mangae these lists.
For each slave is created one list,  plus some counters to track the number of init_command for each transition.  
The mini-xml library
Mini-XML è una piccola libreria gratuita per il parsing di file XML disponibile all'indirizzo  Mini-XML (avaible at http://www.minixml.org) is a small XML library that you can use to read and write XML and XML-like data files in your application without requiring large non-standard libraries. Mini-XML only requires an ANSI C compatible compiler (GCC works, as do most vendors' ANSI C compilers) and a 'make' program.
Mini-XML supports reading of UTF-8 and UTF-16 and writing of UTF-8 encoded XML files and strings. Data is stored in a linked-list tree structure, preserving the XML data hierarchy, and arbitrary element names, attributes, and attribute values are supported with no preset limits, just available memory.

=EcCreateDevice (EcCreateDevice.c)=

This module manages the XML parsing and filles structure's fields with the informationa that are read here. 
Beware that at the end of parsing, network configuration is in an inconsistent status, because the information stored in ec_slave and ec_slaveMore are different from the actual configuration of slaves. For example, for the first slave we read that the physical address is 0x1001 and store this information in  o ec_slave[1].configadr, but the Synch Manager of the slave it hasn't been set yet, so if you try to send an FPRD or FPWR command , the slave don't respond.
To keep track of this inconsistency, at the end of the parsing, all slaves are in a pseudo-state EC_STATE_NONE (remember that the only allowable states for a slave are INIT, PRE-OP, SAFE-OP, OPERATIONAL).

===Function “CreateDevice”===

This is the main function. It takes care of:
-load the XML file. This could be load as a file or as a string buffer (see instruction in the zip file for converting the XML file);
-calculate the number of <Slave> node and store it in ec_slavecount;
-call the function for parsing the <Master> node;
-call the function for parsing the <Slave> node, for each slave;
-call the function for parsing the <Cyclic>node;
-call the function for parsing the <ProcessIamge>node;
in one of the functions above fail, CreateDevice return the error value of  -1.

===function “CreateMaster”===
 
This function read the node <Master> and store the information in ec_slave[0] and ec_slaveMore[0]. 
It creates the before_slave_init_command list, i.e. the commands that has to be sent before the commands in slave's list for a given transition. 

===function “CreateSlave”===

This function read the node <Slave> and for each slave:
-it reads and stores information about the slave (name, physical address, vendorId, product code, revision number etc.);
-it reads the mailbox configuration;
-it creates the Init_command list and calculates the number of commands for each transition;
-it creates the Mailbox_Init_command list. For now, only CoE protocol is implemented.

===function “SetCyclicCmds”===

This function read the node  <Cyclic>. Here are the list of commands to send in OPERATIONAL status.

===function “SetProcImg”===

This function read the node <ProcessImage>. There are two part, one for Input Process Image one for Output Process Image. Both are made as a list of variables. Each variable has the following structure:
-Name
-data type
-bit size
-bit offset (position of the variable within Ethernet frame).
Beware that these offsets are calculated within a frame Ethernet that include ALL the cyclic commands (as read at node <Cyclic>). So you can't use this Process Image configuration with the functions ec_send_processdata() and\or ec_receive_processdata()

===Service functions===

Other functions incluced in EcCreateDEvice module are:

- “ReadECatCmd” that reads each <InitCmd>;
-“ReadCANopenCmd” tha reads <Mailbox><CoE><IntiCmds> node;
-functions for managing lists;
-functions for converting value of parameters reads in the XML file. This parameters are always read as character strings;
-function for resetting data structures.

=InitCmds (InitCmds.c)=

This module manages the network State Machine, according to EtherCAT specification. It compares the requested state wioth the current state and, if different, it calculates the needed transitions and executes the proper Init_commands.

===function “MasterRequestState”===

The input is the requested state. If the requested state is different from the current state, then:
-call the function that calculates the needed transitions e store the value in the global variable  Ec_Transition. Every bit of Ec_Transition is associated to a particular transition (for example bit0 is associated to Init-to-preOp transition, bit1 to preOp-to-SafeOp transition etc.);
-invoke funcion “MasterStateMachine”
if the transition fials, the function returns the error value of -1.

===function “MasterStateMachine”===

For every bit of variables Ec_Transition that is set, this function invoke the proper transition. If the transition is succesfully executed, the corresponding bit of Ec_Transition is reset; then the following bit is checked.

===function “TransitionIP”===

The Init-to-PreOp transition is handled separately from other transitions because here there is the last part of network configuration. This part is took from ethercatconfig.
So this function includes:
-Before_slave_Init_command execution;
-slave's beahviour for non-Ecat frame confiuration;
-Init_command execution;
-configuration of the topology;
-last part of Mailbox configuration;
-update slaves status.

===function “OtherTransitions”===

This function executes all other transition. The steps are the same for every transition:
-execution of Before_slave_Init_commands (if any);
-execution of  slave's Init_command;
-update slaves status.

===function “BeforeSlaveCmd”===

This function executes the command stored in the list of slave[0].


===funcion “SlaveInitCmd”===

This function executes the slave's Init_command for a given transition.
In details:
-it recalls the number of Init command that has to be sent through function “InitCmdNum”
-while the number above is not zero, it goes through the iint_command list and search for the descriptor of the next command to send;
-the descriptor is passed to function “exec_cmd”;
-if it's a PreOp-to-SafeOp transition, before change slave's status, it executes the mailbox Init command as SDO request, by the primitive  “SDO_write” of SOEM;
-if it's a Init-to-PreOp, it changes slave's status to PreOp then send the Mailbox_init_command (if any) as SDO request.
-update slaves status.
Some old Beckhoff slaves require an “expedited” SDO request, while SOEM support only “normal” SDO request. In this case, mailbox init command could fail. Next version of SOEM should solve this problem. 


===function “exec_cmd”===

This function distinguishes commands that need access to EEPROM. In this case the approach is the same of SOEM. Otherwise the function  “EcatCmdReq” is directly called.
Once the command has been executed, this function check the data validation (if needed). If validation fails, or the wkc is different from the expected value, this function tries to send again the command, as many times as provided by the command descriptor itself. 


===function “EcatCmdReq”===

The input is the command descriptor and calls the proper primitive of SOEM. it returns the wkc. 


===Service functions===

-functions “set_sm” and “set_fmmu” update the vale of ec_slave.SM and ec_slave.FMMU every time these parameters are modified by some command. 
-funcion “InitCmdNum” returns the number of  Init_command to execute for a given slave and for a given transition;
-funcion GetTransition” calculates the required transition(s) according to EtherCAT specifications and set the proper bit of variable Ec_Transition. 


==Test==

I've run my tests on a netX500 microcontroller by Hilscher. In my work, these modules are part of my application layer that receives the commands through a Web Server.
If you want to run some form of test like the simple_test.c module of SOEM, you need to write the main function to execute from terminal.
Basically this function has to receive the XML file (if you don't have converted it in a buffer strings and include it to the project), pass the XML file to function “EcCreateDevice” and if the XML file is succesfully parsed, it waits that you select a status for the network and pass the requested status to function “MasterRequestState”


==Maintenance and future developements==
  
If you find any kind of bugs or errors please contact me at viccio75@yahoo.it
Meanwhile i'm working on an extension that manages multicommands frame, in order to speed up the configuration phase and manage the Process Image as required from XML file.