**WARNING: THE LAST DOWNLOAD ADDED INCLUDES A MODIFIED VERSION OF SOEM LIBRARY, SO THIS DOCUMENTATION IS OUT OF DATE, ALTHOUGH IT CAN STILL BE READ TO GET AN IDEA OF MY WORK**



Here is the content of the modules


# Introduction #

While SOEM library provides network configuration only through slaves' scan, with this tool you can configure your network by parsing the ENI XML file generated by TwinCAT.
Moreover this tool provides an implementation of the State Machine, so you can execute whatever transition, thanks to the init commands list included in the ENI XML file.

**This tool acts like an application layer for the SOEM, so no modification to the current version of SOEM is needed.**

# Data structures #


Since Soem doesn't provide space for some information contains in the ENI XML file, new structures has been created.
For example:
  * structure ec\_slaveMore, wich works in parallel with pre-existent ec\_slave of SOEM;
  * Init\_commands. Since the number of  init commands is variable (both for slave and transition), these commands are inserted in dynamic lists.
Obviously, it has been created also the functions to manage these lists.
For each slave is created one list,  plus some counters to track the number of init\_command for each transition.

# The mini-xml library #

Mini-XML (available at http://www.minixml.org) is a small XML library that you can use to read and write XML and XML-like data files in your application without requiring large non-standard libraries. Mini-XML only requires an ANSI C compatible compiler (GCC works, as do most vendors' ANSI C compilers) and a 'make' program.
Mini-XML supports reading of UTF-8 and UTF-16 and writing of UTF-8 encoded XML files and strings. Data is stored in a linked-list tree structure, preserving the XML data hierarchy, and arbitrary element names, attributes, and attribute values are supported with no preset limits, just available memory.

# EcCreateDevice.c #

This module manages the XML parsing and filles structure's fields with the informationa that are read here.
Beware that at the end of parsing, network configuration is in an inconsistent status, because the information stored in ec\_slave and ec\_slaveMore are different from the actual configuration of slaves. For example, for the first slave we read that the physical address is 0x1001 and store this information in ec\_slave`[`1`]`.configadr, but the Synch Manager of the slave it hasn't been set yet, so if you try to send an FPRD or FPWR command , the slave don't respond.
To keep track of this inconsistency, at the end of the parsing, all slaves are in a pseudo-state EC\_STATE\_NONE (remember that the only allowable states for a slave are INIT, PRE-OP, SAFE-OP, OPERATIONAL).

### Function "CreateDevice" ###

This is the main function. It takes care of:
  * load the XML file. This could be load as a file or as a string buffer (see instruction in the zip file for converting the XML file);
  * calculate the number of `<`Slave`>` node and store it in ec\_slavecount;
  * call the function for parsing the `<`Master`>` node;
  * call the function for parsing the `<`Slave`>` node, for each slave;
  * call the function for parsing the `<`Cyclic`>` node;
  * call the function for parsing the `<`ProcessImage`>` node.

In one of the functions above fail, CreateDevice return the error value of  -1.

### function “CreateMaster” ###

This function read the node `<`Master`>` and store the information in ec\_slave`[`0`]` and ec\_slaveMore`[`0`]`.
It creates the before\_slave\_init\_command list, i.e. the commands that has to be sent before the commands in slave's list for a given transition.

### function “CreateSlave” ###

This function read the node `<`Slave`>` and for each slave:
  * it reads and stores information about the slave (name, physical address, vendorId, product code, revision number etc.);
  * it reads the mailbox configuration;
  * it creates the Init\_command list and calculates the number of commands for each transition;
  * it creates the Mailbox\_Init\_command list. For now, only CoE protocol is implemented.

### function “SetCyclicCmds” ###

This function reads the node `<`Cyclic`>`. Here there are the list of commands to send in OPERATIONAL status.

### function “SetProcImg” ###

This function read the node `<`ProcessImage`>`. There are two part, one for Input Process Image one for Output Process Image. Both are made as a list of variables. Each variable has the following structure:
  * Name
  * data type
  * bit size
  * bit offset (position of the variable within Ethernet frame).

Beware that these offsets are calculated within a frame Ethernet that include ALL the cyclic commands (as read at node `<`Cyclic`>`). So you can't use this Process Image configuration with the functions ec\_send\_processdata() and\or ec\_receive\_processdata()

### Service functions ###

Other functions incluced in EcCreateDEvice module are:

  * “ReadECatCmd” that reads each `<`InitCmd`>`;
  * “ReadCANopenCmd” tha reads `<`Mailbox`>``<`CoE`>``<`IntiCmds`>` node;
  * functions for managing lists;
  * functions for converting value of parameters reads in the XML file. This parameters are always read as character strings;
  * function for resetting data structures.

# InitCmds (InitCmds.c) #

This module manages the network State Machine, according to EtherCAT specification. It compares the requested state wioth the current state and, if different, it calculates the needed transitions and executes the proper Init\_commands.

### function “MasterRequestState” ###

The input is the requested state. If the requested state is different from the current state, then:
  * call the function that calculates the needed transitions e store the value in the global variable  Ec\_Transition. Every bit of Ec\_Transition is associated to a particular transition (for example bit0 is associated to Init-to-preOp transition, bit1 to preOp-to-SafeOp transition etc.);
  * invoke funcion “MasterStateMachine”
if the transition fails, the function returns the error value of -1.

### function “MasterStateMachine” ###

For every bit of variables Ec\_Transition that is set, this function invoke the proper transition. If the transition is succesfully executed, the corresponding bit of Ec\_Transition is reset; then the following bit is checked.

### function “TransitionIP” ###

The Init-to-PreOp transition is handled separately from other transitions because here there is the last part of network configuration. This part is took from ethercatconfig.
So this function includes:
  * Before\_slave\_Init\_command execution;
  * slave's beahviour for non-Ecat frame confiuration;
  * Init\_command execution;
  * configuration of the topology;
  * last part of Mailbox configuration;
  * update slaves status.

### function “OtherTransitions” ###

This function executes all other transition. The steps are the same for every transition:
  * execution of Before\_slave\_Init\_commands (if any);
  * execution of  slave's Init\_command;
  * update slaves status.

### function “BeforeSlaveCmd” ###

This function executes the command stored in the list of slave`[`0`]`.


### funcion “SlaveInitCmd” ###

This function executes the slave's Init\_command for a given transition.
In details:
  * it recalls the number of Init command that has to be sent through function “InitCmdNum”
  * while the number above is not zero, it goes through the iint\_command list and search for the descriptor of the next command to send;
  * the descriptor is passed to function “exec\_cmd”;
  * if it's a PreOp-to-SafeOp transition, before change slave's status, it executes the mailbox Init command as SDO request, by the primitive  “SDO\_write” of SOEM;
  * if it's a Init-to-PreOp, it changes slave's status to PreOp then send the Mailbox\_init\_command (if any) as SDO request.
  * update slaves status.

Some old Beckhoff slaves require an “expedited” SDO request, while SOEM support only “normal” SDO request. In this case, mailbox init command could fail. Next version of SOEM should solve this problem.


### function “exec\_cmd” ###

This function distinguishes commands that need access to EEPROM. In this case the approach is the same of SOEM. Otherwise the function  “EcatCmdReq” is directly called.
Once the command has been executed, this function check the data validation (if needed). If validation fails, or the wkc is different from the expected value, this function tries to send again the command, as many times as provided by the command descriptor itself.


### function “EcatCmdReq” ###

The input is the command descriptor and calls the proper primitive of SOEM. it returns the wkc.


### Service functions ###

  * functions “set\_sm” and “set\_fmmu” update the vale of ec\_slave.SM and ec\_slave.FMMU every time these parameters are modified by some command.
  * funcion “InitCmdNum” returns the number of  Init\_command to execute for a given slave and for a given transition;
  * funcion GetTransition” calculates the required transition(s) according to EtherCAT specifications and set the proper bit of variable Ec\_Transition.


## Test ##

I've run my tests on a netX500 microcontroller by Hilscher. In my work, these modules are part of my application layer that receives the commands through a Web Server.
If you want to run some form of test like the simple\_test.c module of SOEM, you need to write the main function to execute from terminal.
Basically this function has to receive the XML file (if you don't have converted it in a buffer strings and include it to the project), pass the XML file to function “EcCreateDevice” and if the XML file is succesfully parsed, it waits that you select a status for the network and pass the requested status to function “MasterRequestState”



## Maintenance and future developements ##

If you find any kind of bugs or errors please contact me at viccio75@yahoo.it
Meanwhile i'm working on an extension that manages multicommands frame, in order to speed up the configuration phase and manage the Process Image as required from XML file.